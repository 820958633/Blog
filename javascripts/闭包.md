# 闭包

- 闭包是指有权访问到另外一个函数作用域中变量的函数。创建闭包的最常见的方式就是在一个函数内部创建

另一个函数，创建的函数可以访问到当前函数的局部变量。

- 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

```javascript
// 函数作为返回值
function create() {
  const a = 100;
  return () => {
    console.log(a);
  }
}
const fn = create();
const a = 200;
console.log(a) // 100

// 函数作为参数
function print(fn) {
  const a = 200;
  fn()
}

const a = 100;
function fn() {
  console.log(a);
}
print(fn); // 100
```

**闭包：自由变量的查找，是在函数声明的地方向上级作用域进行查找，而不是在函数执行的地方！！！**

在JS中，闭包存在的意义就是让我们可以间接的访问函数内部的变量。

经典面试题：循环中使用闭包解决var定义函数问题。

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

因为setTimeout是个异步函数，所以会先把循环全部执行完，此时i为5，所以打印会输出一堆5。解决办法有三种：

- 闭包：

```javascript
for (var i = 1; i <= 5; i++) {
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    },j*1000)
  })(i)
}
```

在上述代码中，首先使用了立即执行函数将i传入函数内部，这个时候值就被固定在了参数j上面不会改变，当下次执行timer这个闭包的时候，就可以使用外部函数的变量j。

- 使用setTimeout的第三个参数，这个参数会被当做timer函数的参数传入。

```javascript
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer(j){
      console.log(j)
    },i*1000,i)
}
```

- 第三种就是使用let定义i，这种方法最简单也最推荐。

```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer(){
    console.log(i)
  },i*1000)
}
```

## 闭包与内存管理

首先明确一个概念，闭包并不意味着内存泄露，这跟JS本身没有任何关系。

局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直存在。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们主动选择把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，**把这些变量放在闭包中和放在全局的作用域，对内存的影响是一致的，这里并不能说是内存泄露。**如果在将来需要回收这些变量，我们可以手动把这些变量设为null，该变量就会在下一次垃圾回收时被清理掉。

跟闭包和内存泄露有关系的地方是，**使用闭包的同时比较容易形成循环引用。**在早期的IE6浏览器中，由于BOM和DOM中的对象是使用C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是**引用计数策略**。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露本质上也不是闭包造成的。

**应用场景：防抖、节流、库的封装（保证数据私密性）**
